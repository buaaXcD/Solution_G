# Solution_G
## 题目分析
如题意，本题的目标就是输入一串排列，并求出这串排列的**逆序数**。若逆序数为偶数，则输出`Alice`，若逆序数为奇数，则输出`Bob`。
## 尝试
根据高等代数中所学求逆序数的方法，对一串有 $n$ 个数的排列 $a[0],a[1],...,a[n-1]$ ，第一次先从 $a[1]$ 开始，检查 $a[0]$ 是否小于 $a[1]$ ，若大于，则逆序数加 1 ，若小于，则逆序数不变；第二次再判断 $a[2]$ ，从 $a[0]$ 到 $a[1]$ ，判断这一串数中有多少个数大于 $a[2]$ ，有多少个数大于 $a[2]$ ，则逆序数的大小就加几；第 $i$ 次则判断 $a[i]$ ,从 $a[0]$ 到 $a[i-1]$ ，判断这一串数中有多少个数大于 $a[i]$ ，有多少个数大于 $a[i]$ ，则逆序数的大小就加几，直至判断至 $a[n-1]$ ，所得即为这一串排序的逆序数。于是我们可以轻松地得到以下代码：
```
#include <stdio.h>
int a[100005];
int main()
{
	int t,n;
	long long sum;
	scanf("%d",&t);
	for (int k=0;k<t;k++)
	{
		sum=0;
		scanf("%d",&n);
		for (int i=0;i<n;i++)
		scanf("%d",&a[i]);
		for (int i=1;i<n;i++)
		{
			for (int j=0;j<i;j++)
			{
				if (a[j]>a[i])
				sum++;
			}
		}
		if (sum%2==0)
		printf("Alice\n");
		else
		printf("Bob\n");
	}
}

```
G题果然不会如此简单，这一段代码的评测结果不出所料地 **TLE** 了。分析代码，代码中存在两层循环嵌套，时间复杂度为 $n^2$ ,而根据题目所给数据范围， $n$ 的最大值可达到 $10^5$ ，对于这样的数据范围很容易超时，所以这样使用了两层嵌套的代码是不可取的。
## 优化
### 大致思路
对于一串排序，任意交换其中两个元素的位置，逆序数会 $+1$ 。既然输入的这一串排序是由最初正常的排序（即 $1,2,...,n$ ）转换而来，我们不妨一步一步将其变成正常的排序。每一步取其中一个数字，若它正好处在它自己应该所在的位置，则不做处理，逆序数不变；若它不处于自己应该所在的位置，则把它与本应在它自己位置上的数字进行交换，再将逆序数 $+1$ ，并开始检索下一个数字，最终得到最初的排序。

为了方便理解，给出以下例子。

假设给出一串排序，其排序如下：
```
1 3 5 4 2
```
定义一个变量 `sum` 用于计算这串排序的逆序数，并初始化为 `0` 。

第一步，先将数字 5 放置在其正确的位置上，即此时 2 所在的位置，将二者交换。此时 `sum` 为 `1` ，并得到以下序列：
```
1 3 2 4 5
```
第二步，将数字 4 放置在其正确的位置上，此时数字 4 已处在第 4 个位置上，所以无需交换，此时 `sum` 仍为 `1` 。

第三步，将数字 3 放置在其正确的位置上，即此时 2 所在的位置，将二者交换。此时 `sum` 为 `2` ，并得到以下序列：
```
1 2 3 4 5
```
第四步，将数字 2 放置在其正确的位置上，此时数字 2 已处在第 2 个位置上，所以无需交换，此时 `sum` 仍为 `2` 。

第五步，将数字 1 放置在其正确的位置上，此时数字 1 已处在第 1 个位置上，所以无需交换，此时 `sum` 仍为 `2` 。

于是可以得到原排序的逆序数是 `2` 。

### 代码框架
在此题的代码中，需要使用到两个数组。数组 `a` 用于储存此时序列的排序，数组 `b` 用于储存数字在数组 `a` 中所在的位置。

在输入阶段可以得到以下代码：
```
for (int i=1;i<=n;i++)
{
  scanf("%d",&a[i]);
  b[a[i]]=i;
}
```
下一步就是按序将排列复原回到升序的排列，我们按降序的排列一个一个将数字放置在其正确的位置上。

对于数字 i ，我们第一步要做的就是判断它是否在自己正确的位置上，即 `a[i]==i` 是否成立。若不成立，我们就需要将 `a[i]` 与 i 进行互换，而 i 在 `a` 中的位置为 `b[i]` ，即这一步操作为将 `a[i]` 与 `a[b[i]]` 位置互换。同时不能忘记互换相应的 `b` 中的位置并将 `sum` 加 1 。

可以得到以下代码：
```
for (int i=n;i>0;i--)
{
  if(a[i]!=i)
  {
    sum++;
    temp=a[i];
    a[i]=i;
    a[b[i]]=temp;
    temp2=b[temp];
    b[temp]=b[i];
	  b[i]=temp2;
  }
}
```
最后根据得到的逆序数判断相应的输出即可。
## 完整代码
```
#include <stdio.h>
int a[100005];
int b[100005];
int main()
{
	int t,n;
	scanf("%d",&t);
	for (int k=0;k<t;k++)
	{
		int sum=0,temp,temp2;
		scanf("%d",&n);
		for (int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			b[a[i]]=i;
		}
		for (int i=n;i>0;i--)
		{
			if(a[i]!=i)
			{
				sum++;
				temp=a[i];
				a[i]=i;
				a[b[i]]=temp;
				temp2=b[temp];
				b[temp]=b[i];
				b[i]=temp2;
			}
		}
		if (sum%2==0)
		printf("Alice\n");
		else
		printf("Bob\n");
	}
}
```
